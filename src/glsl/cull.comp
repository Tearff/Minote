#version 460
#pragma shader_stage(compute)

layout(local_size_x = 64) in;

struct Command {
	uint indexCount;
	uint instanceCount;
	uint firstIndex;
	uint vertexOffset;
	uint firstInstance;
	float meshRadius;
};
layout (binding = 0, std430) buffer Draws {
	Command draws[];
};

struct Instance {
	mat4 transform;
	vec4 tint;
	float roughness;
	float metalness;
	uint meshID;
	float pad0;
};
layout (binding = 1, std430) readonly buffer Instances {
	Instance instances[];
};
layout (binding = 2, std430) writeonly buffer InstancesCulled {
	Instance instancesCulled[];
};

layout(binding = 3) uniform CullData {
	mat4 view;
	vec4 frustum;
	uint instancesCount;
};

float maxScale(mat4 transform) {
	float x = length(vec3(transform[0][0], transform[0][1], transform[0][2]));
	float y = length(vec3(transform[1][0], transform[1][1], transform[1][2]));
	float z = length(vec3(transform[2][0], transform[2][1], transform[2][2]));
	return max(x, max(y, z));
}

bool visible(uint gid, float radius) {
	vec3 center = (view * instances[gid].transform[3]).xyz;

	bool result = true;
	result = result && center.z * frustum[1] - abs(center.x) * frustum[0] > -radius;
	result = result && center.z * frustum[3] - abs(center.y) * frustum[2] > -radius;

	return result;
}

void main() {
	uint gid = gl_GlobalInvocationID.x;
	if (gid >= instancesCount) return;

	uint meshID = instances[gid].meshID;
	float scale = maxScale(instances[gid].transform);
	float radius = draws[meshID].meshRadius;
	if (!visible(gid, radius * scale)) return;

	uint offset = draws[meshID].firstInstance;
	uint index = atomicAdd(draws[meshID].instanceCount, 1);
	instancesCulled[offset + index] = instances[gid];
}
