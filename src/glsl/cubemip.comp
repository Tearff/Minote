#version 460
#pragma shader_stage(compute)
#extension GL_EXT_nonuniform_qualifier: enable
#extension GL_KHR_shader_subgroup_clustered: enable

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, rgba16f) restrict coherent uniform image2DArray cubemap[];
layout(set = 1, binding = 0) restrict coherent buffer Atomics {
	vec4 finalCache[256 * 6];
	uint groupsFinished[6];
};
layout(set = 1, binding = 1) uniform sampler2DArray cubemapBase;

// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/
uint Compact1By1(uint x) {
	x &= 0x55555555u;                  // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0
	x = (x ^ (x >>  1)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10
	x = (x ^ (x >>  2)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210
	x = (x ^ (x >>  4)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210
	x = (x ^ (x >>  8)) & 0x0000ffffu; // x = ---- ---- ---- ---- fedc ba98 7654 3210
	return x;
}

uvec2 MortonOrder(uint id) {
	return uvec2(Compact1By1(id), Compact1By1(id >> 1));
}

vec4 SampleBase(uvec2 id, vec2 tex) {
	return textureLod(cubemapBase, vec3(tex * vec2(id), gl_GlobalInvocationID.z), 0.0);
}

void MipStore(uint mip, uvec2 id, vec4 val) {
	imageStore(cubemap[mip], ivec3(id, gl_GlobalInvocationID.z), val);
}

shared vec4 localCache[gl_WorkGroupSize.x * gl_WorkGroupSize.y];

void LocalStore(uvec2 id, uint width, vec4 val) {
	localCache[id.y * width + id.x] = val;
}

vec4 LocalLoad(uvec2 id, uint width) {
	return localCache[id.y * width + id.x];
}

shared bool isFinal;

void FinalStore(uvec2 id, uint width, vec4 val) {
	finalCache[gl_GlobalInvocationID.z * 256 + id.y * width + id.x] = val;
}

vec4 FinalLoad(uvec2 id, uint width) {
	return finalCache[gl_GlobalInvocationID.z * 256 + id.y * width + id.x];
}

void main() {
	const uvec2 localID = MortonOrder(gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID);
	const uvec2 groupOffset = gl_WorkGroupSize.xy * gl_WorkGroupID.xy;
	const uvec2 globalID = groupOffset + localID;
	if (all(equal(globalID, uvec2(0))))
		groupsFinished[gl_GlobalInvocationID.z] = 0;

	// Initial 2 mips - sample the initial texture 4 times
	const vec2 baseTex = vec2(1.0) / vec2(textureSize(cubemapBase, 0).xy);
	vec4 sample00 = SampleBase(globalID * 4 + uvec2(1, 1), baseTex);
	MipStore(1, globalID * 2 + uvec2(0, 0), sample00);
	vec4 sample10 = SampleBase(globalID * 4 + uvec2(3, 1), baseTex);
	MipStore(1, globalID * 2 + uvec2(1, 0), sample10);
	vec4 sample01 = SampleBase(globalID * 4 + uvec2(1, 3), baseTex);
	MipStore(1, globalID * 2 + uvec2(0, 1), sample01);
	vec4 sample11 = SampleBase(globalID * 4 + uvec2(3, 3), baseTex);
	MipStore(1, globalID * 2 + uvec2(1, 1), sample11);
	vec4 sampleAvg = (sample00 + sample10 + sample01 + sample11) * 0.25;
	MipStore(2, globalID, sampleAvg);

	// Calculate as many mips as possible using subgroup sharing,
	// synchronize, and repeat until the group is reduced to 1x1
	uint mip = 3;
	uint offset = 1;
	uint localOffset;
	const uint opsPerLoop =
		gl_SubgroupSize >= 64? 4 :
		gl_SubgroupSize >= 16? 3 :
		gl_SubgroupSize >=  4? 2 :
		1;
	const uint mipsToGenerate = 4;
	const uint iterations = uint(ceil(float(mipsToGenerate) / float(opsPerLoop)));
	for (uint i = 0; i < iterations; i++) {
		localOffset = 1;
		if (gl_SubgroupSize >= 4 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 4);
				sampleAvg /= 4.0;
				if (gl_SubgroupInvocationID % 4 == 0)
					MipStore(mip, groupOffset / (offset * 2) + localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (gl_SubgroupSize >= 16 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 16);
				sampleAvg /= 16.0;
				if (gl_SubgroupInvocationID % 16 == 0)
					MipStore(mip, groupOffset / (offset * 2) + localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (gl_SubgroupSize >= 64 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 64);
				sampleAvg /= 64.0;
				if (gl_SubgroupInvocationID % 64 == 0)
					MipStore(mip, groupOffset / (offset * 2) + localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (offset < gl_WorkGroupSize.x) {
			if (all(equal(localID % localOffset, uvec2(0))))
				if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset))))
					LocalStore(localID / localOffset, gl_WorkGroupSize.x / localOffset, sampleAvg);
			memoryBarrierShared();
			barrier();
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset * 2)))) {
				sample00 = LocalLoad(localID * 2 + uvec2(0, 0),  gl_WorkGroupSize.x / localOffset);
				sample10 = LocalLoad(localID * 2 + uvec2(1, 0),  gl_WorkGroupSize.x / localOffset);
				sample01 = LocalLoad(localID * 2 + uvec2(0, 1),  gl_WorkGroupSize.x / localOffset);
				sample11 = LocalLoad(localID * 2 + uvec2(1, 1),  gl_WorkGroupSize.x / localOffset);
				sampleAvg = (sample00 + sample10 + sample01 + sample11) * 0.25;
				MipStore(mip, groupOffset / (offset * 2) + localID, sampleAvg);
			}
			mip += 1;
			offset *= 2;
		}
	}

	// Save the final value into the final buffer, and all groups but one quit
	const uint finalWidth = textureSize(cubemapBase, 0).x / (gl_WorkGroupSize.x * 4);
	if (localID == uvec2(0)) {
		FinalStore(gl_WorkGroupID.xy, finalWidth, sampleAvg);
		uint finishIndex = atomicAdd(groupsFinished[gl_GlobalInvocationID.z], 1) + 1;
		isFinal = (finishIndex == gl_NumWorkGroups.x * gl_NumWorkGroups.y);
	}

	memoryBarrierShared();
	memoryBarrierBuffer();
	barrier();
	if (!isFinal)
		return;

	// As the final group, finish filling in all remaining mips
	sampleAvg = FinalLoad(localID, finalWidth);

	const uint finalMipsToGenerate =
		textureSize(cubemapBase, 0).x >= 1024? 4 :
		textureSize(cubemapBase, 0).x >=  512? 3 :
		textureSize(cubemapBase, 0).x >=  256? 2 :
		textureSize(cubemapBase, 0).x >=  128? 1 : 0;
	const uint finalIterations = uint(ceil(float(finalMipsToGenerate) / float(opsPerLoop)));
	offset = 1 << (4 - finalMipsToGenerate);
	for (uint i = 0; i < finalIterations; i++) {
		localOffset = 1;
		if (gl_SubgroupSize >= 4 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 4);
				sampleAvg /= 4.0;
				if (gl_SubgroupInvocationID % 4 == 0)
				MipStore(mip, localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (gl_SubgroupSize >= 16 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 16);
				sampleAvg /= 16.0;
				if (gl_SubgroupInvocationID % 16 == 0)
				MipStore(mip, localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (gl_SubgroupSize >= 64 && offset < gl_WorkGroupSize.x) {
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset)))) {
				sampleAvg = subgroupClusteredAdd(sampleAvg, 64);
				sampleAvg /= 64.0;
				if (gl_SubgroupInvocationID % 64 == 0)
				MipStore(mip, localID / (localOffset * 2), sampleAvg);
			}
			mip += 1;
			offset *= 2;
			localOffset *= 2;
		}
		if (offset < gl_WorkGroupSize.x) {
			if (all(equal(localID % localOffset, uvec2(0))))
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset / localOffset))))
			LocalStore(localID / localOffset, gl_WorkGroupSize.x / localOffset, sampleAvg);
			memoryBarrierShared();
			barrier();
			if (all(lessThan(localID, gl_WorkGroupSize.xy / (offset * 2)))) {
				sample00 = LocalLoad(localID * 2 + uvec2(0, 0),  gl_WorkGroupSize.x / localOffset);
				sample10 = LocalLoad(localID * 2 + uvec2(1, 0),  gl_WorkGroupSize.x / localOffset);
				sample01 = LocalLoad(localID * 2 + uvec2(0, 1),  gl_WorkGroupSize.x / localOffset);
				sample11 = LocalLoad(localID * 2 + uvec2(1, 1),  gl_WorkGroupSize.x / localOffset);
				sampleAvg = (sample00 + sample10 + sample01 + sample11) * 0.25;
				MipStore(mip, localID, sampleAvg);
			}
			mip += 1;
			offset *= 2;
		}
	}
}
