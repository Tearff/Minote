#version 460
#pragma shader_stage(compute)

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 1, binding = 0) uniform sampler2D skyView;
layout(set = 1, binding = 1, rgba16f) restrict writeonly uniform imageCube cubemap;
layout(set = 1, binding = 2) uniform Sides {
	mat4 sides[6];
};

#include "sky.glslh"

void main() {
	const uvec3 gid = gl_GlobalInvocationID;
	const ivec2 size = imageSize(cubemap);
	const ivec2 viewSize = textureSize(skyView, 0);

	vec2 uv = (vec2(gid.xy) + vec2(0.5)) / vec2(size);
	uv = uv * 2.0 - 1.0;
	vec3 dir = mat3(sides[gid.z]) * vec3(uv, 1.0);

	vec3 WorldDir = normalize(dir);
	vec3 WorldPos = camera + vec3(0.0, 0.0, Atmosphere.BottomRadius);

	float viewHeight = length(WorldPos);
	
	if (viewHeight < Atmosphere.TopRadius) {
		vec2 uv;
		vec3 UpVector = normalize(WorldPos);
		float viewZenithCosAngle = dot(WorldDir, UpVector);

		vec3 sideVector = normalize(cross(UpVector, WorldDir)); // assumes non parallel vectors
		vec3 forwardVector = normalize(cross(sideVector, UpVector)); // aligns toward the sun light but perpendicular to up vector
		vec2 lightOnPlane = vec2(dot(sun_direction, forwardVector), dot(sun_direction, sideVector));
		lightOnPlane = normalize(lightOnPlane);
		float lightViewCosAngle = lightOnPlane.x;

		bool IntersectGround = raySphereIntersectNearest(WorldPos, WorldDir, vec3(0.0), Atmosphere.BottomRadius) >= 0.0;

		SkyViewLutParamsToUv(IntersectGround, viewZenithCosAngle, lightViewCosAngle, viewSize, viewHeight, uv);
		vec4 result = vec4(textureLod(skyView, uv, 0.0).rgb + GetSunLuminance(WorldPos, WorldDir, Atmosphere.BottomRadius), 1.0) * 10.0;
		result.rgb *= 10.0;
		imageStore(cubemap, ivec3(gid), result);
	} else {
		imageStore(cubemap, ivec3(gid), vec4(0.0, 0.0, 0.0, 1.0));
	}
}
